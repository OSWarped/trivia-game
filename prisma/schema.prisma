datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id             String   @id @default(uuid())
  email          String   @unique @db.Citext
  password       String
  name           String
  roles          String[] // Array of roles (e.g., 'ADMIN', 'HOST', etc.)
  memberships    TeamMembership[] // Join table for teams and games
  captainedTeams Team[]   @relation("Captain")
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model Team {
  id              String   @id @default(uuid())
  name            String
  memberships     TeamMembership[] // Join table for users in this team
  captainId       String? // Optional reference to the captain
  captain         User?    @relation("Captain", fields: [captainId], references: [id])
  gameId          String
  game            Game     @relation(fields: [gameId], references: [id])
  score           Int      @default(0)
  remainingPoints Int[]    // Array of remaining points per round
  answers         Answer[] // Add reverse relation to answers
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model TeamMembership {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  teamId    String
  team      Team     @relation(fields: [teamId], references: [id])
  gameId    String

  @@unique([userId, gameId]) // Enforce one team per user per game
}

model HostingSite {
  id        String   @id @default(uuid())
  name      String   @unique
  location  String
  games     Game[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Game {
  id            String      @id @default(uuid())
  hostingSiteId String
  hostingSite   HostingSite @relation(fields: [hostingSiteId], references: [id])
  hostId        String // Directly reference the hostId
  date          DateTime
  name          String
  status        String      @default("PENDING") // PENDING, STARTED, COMPLETED
  startedAt     DateTime? // Optional field for when the game is started
  teams         Team[]     // Teams participating in the game
  rounds        Round[]    // Each game has multiple rounds
  gameState     GameState? @relation // No `fields` or `references` here
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
}

model GameState {
  id              String   @id @default(uuid())
  gameId          String   @unique
  game            Game     @relation(fields: [gameId], references: [id]) // Specify `fields` and `references` here
  currentRoundId  String?  // Tracks the current round
  currentQuestionId String? // Tracks the current question
  isTransitioning Boolean   @default(false) // Indicates if the game is in a transition
  transitionMessage String? // Custom message for the transition page
  transitionMedia  String?  // Media URL for the transition page
  adEmbedCode      String?  // HTML or JavaScript embed code for ads/videos
  scoresVisibleToPlayers Boolean @default(false) // New flag for score visibility
  updatedAt       DateTime @updatedAt
  createdAt       DateTime @default(now())
}

model Round {
  id          String      @id @default(uuid())
  name        String
  gameId      String
  game        Game        @relation(fields: [gameId], references: [id])
  roundType   RoundType
  maxPoints   Int?
  timeLimit   Int?
  wagerLimit  Int?
  pointSystem PointSystem
  pointPool   Int[]
  pointValue  Int?
  sortOrder   Int
  questions   Question[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model Question {
  id            String         @id @default(uuid())
  text          String
  type          QuestionType
  pointValue    Int?
  roundId       String
  round         Round          @relation(fields: [roundId], references: [id])
  correctAnswer CorrectAnswer? @relation
  answers       Answer[] // A question can have multiple answers (one per team)
  subquestions  Subquestion[]
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
}

model Answer {
  id            String   @id @default(uuid())
  questionId    String
  question      Question @relation(fields: [questionId], references: [id])
  teamId        String
  team          Team     @relation(fields: [teamId], references: [id])
  answer        String
  isCorrect     Boolean
  pointsUsed    Int
  pointsAwarded Int
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Subquestion {
  id            String      @id @default(uuid())
  questionId    String
  question      Question    @relation(fields: [questionId], references: [id])
  text          String
  correctAnswer CorrectSubquestion?
  pointsAwarded Int
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}

model CorrectAnswer {
  id         String   @id @default(uuid())
  answer     String
  questionId String   @unique
  question   Question @relation(fields: [questionId], references: [id])
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model CorrectSubquestion {
  id            String      @id @default(uuid())
  answer        String
  subquestionId String      @unique
  subquestion   Subquestion @relation(fields: [subquestionId], references: [id])
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}

enum GameMode {
  TIME_BASED
  POINT_ASSIGNMENT
  COMBO
}

enum RoundType {
  POINT_BASED
  TIME_BASED
  WAGER
  LIGHTNING
  IMAGE
}

enum PointSystem {
  POOL
  FLAT
}

enum QuestionType {
  SINGLE
  MULTIPLE_CHOICE
  ORDERED
  WAGER
  IMAGE
}
