datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id              String            @id @default(uuid())
  email           String            @unique @db.Citext
  password        String
  name            String
  roles           String[] // Array of roles (e.g., 'ADMIN', 'HOST', etc.)
  memberships     TeamMembership[] // Join table for teams and games
  captainedTeams  Team[]            @relation("Captain")
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  SiteMembership  SiteMembership[]
  TeamJoinRequest TeamJoinRequest[]
  Notification    Notification[]
}

model Team {
  id              String            @id @default(uuid())
  name            String
  memberships     TeamMembership[] // Join table for users in this team
  captainId       String? // Optional reference to the captain
  captain         User?             @relation("Captain", fields: [captainId], references: [id])
  hostingSites    HostingSite[]     @relation("TeamHostingSites")
  score           Int               @default(0)
  remainingPoints Int[] // Array of remaining points per round
  answers         Answer[] // Add reverse relation to answers
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  TeamHostingSite TeamHostingSite[]
  TeamJoinRequest TeamJoinRequest[]
  teamGames       TeamGame[] // Many-to-many relationship with Games
}

model TeamMembership {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  teamId    String
  team      Team     @relation(fields: [teamId], references: [id])
  status    String   @default("ACTIVE") // ACTIVE, PENDING, REMOVED
  createdAt DateTime @default(now())

  @@unique([userId]) // Enforce one team per user per game
}

model HostingSite {
  id              String            @id @default(uuid())
  name            String            @unique
  location        String
  games           Game[]
  teams           Team[]            @relation("TeamHostingSites")
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  TeamHostingSite TeamHostingSite[]
  SiteMembership  SiteMembership[]
}

model TeamHostingSite {
  id            String      @id @default(uuid())
  teamId        String
  team          Team        @relation(fields: [teamId], references: [id])
  hostingSiteId String
  hostingSite   HostingSite @relation(fields: [hostingSiteId], references: [id])

  @@unique([teamId, hostingSiteId]) // Prevent duplicate assignments
}

model TeamGame {
  id        String   @id @default(uuid())
  teamId    String
  gameId    String
  team      Team     @relation(fields: [teamId], references: [id])
  game      Game     @relation(fields: [gameId], references: [id])
  createdAt DateTime @default(now())

  @@unique([teamId, gameId]) // Ensure a team can't join the same game twice
}

model Game {
  id            String      @id @default(uuid())
  hostingSiteId String
  hostingSite   HostingSite @relation(fields: [hostingSiteId], references: [id])
  hostId        String // Directly reference the hostId
  date          DateTime
  name          String
  status        String      @default("PENDING") // PENDING, STARTED, COMPLETED
  startedAt     DateTime? // Optional field for when the game is started
  rounds        Round[] // Each game has multiple rounds
  gameState     GameState?  @relation // No `fields` or `references` here
  teamGames     TeamGame[] // Many-to-many relationship with Teams
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}

model GameState {
  id                     String   @id @default(uuid())
  gameId                 String   @unique
  game                   Game     @relation(fields: [gameId], references: [id]) // Specify `fields` and `references` here
  currentRoundId         String? // Tracks the current round
  currentQuestionId      String? // Tracks the current question
  isTransitioning        Boolean  @default(false) // Indicates if the game is in a transition
  transitionMessage      String? // Custom message for the transition page
  transitionMedia        String? // Media URL for the transition page
  adEmbedCode            String? // HTML or JavaScript embed code for ads/videos
  scoresVisibleToPlayers Boolean  @default(false) // New flag for score visibility
  pointPool              Int[] // Array of points available for the pool round
  pointsRemaining        Json? // JSON object to track remaining points for each team
  updatedAt              DateTime @updatedAt
  createdAt              DateTime @default(now())
}

model Round {
  id          String      @id @default(uuid())
  name        String
  gameId      String
  game        Game        @relation(fields: [gameId], references: [id])
  roundType   RoundType
  maxPoints   Int?
  timeLimit   Int?
  wagerLimit  Int?
  pointSystem PointSystem
  pointPool   Int[]
  pointValue  Int?
  sortOrder   Int
  questions   Question[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model Question {
  id            String         @id @default(uuid())
  text          String
  type          QuestionType
  pointValue    Int?
  roundId       String
  round         Round          @relation(fields: [roundId], references: [id])
  correctAnswer CorrectAnswer? @relation
  answers       Answer[] // A question can have multiple answers (one per team)
  subquestions  Subquestion[]
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
}

model Answer {
  id            String   @id @default(uuid())
  questionId    String
  question      Question @relation(fields: [questionId], references: [id])
  teamId        String
  team          Team     @relation(fields: [teamId], references: [id])
  answer        String
  isCorrect     Boolean
  pointsUsed    Int
  pointsAwarded Int
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Subquestion {
  id            String              @id @default(uuid())
  questionId    String
  question      Question            @relation(fields: [questionId], references: [id])
  text          String
  correctAnswer CorrectSubquestion?
  pointsAwarded Int
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
}

model CorrectAnswer {
  id         String   @id @default(uuid())
  answer     String
  questionId String   @unique
  question   Question @relation(fields: [questionId], references: [id])
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model CorrectSubquestion {
  id            String      @id @default(uuid())
  answer        String
  subquestionId String      @unique
  subquestion   Subquestion @relation(fields: [subquestionId], references: [id])
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}

model SiteMembership {
  id            String      @id @default(uuid())
  userId        String
  user          User        @relation(fields: [userId], references: [id])
  hostingSiteId String
  hostingSite   HostingSite @relation(fields: [hostingSiteId], references: [id])
  createdAt     DateTime    @default(now())

  @@unique([userId, hostingSiteId]) // Prevent duplicate memberships
}

model TeamJoinRequest {
  id          String    @id @default(uuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  teamId      String
  team        Team      @relation(fields: [teamId], references: [id])
  status      String    @default("PENDING") // PENDING, APPROVED, DECLINED
  requestedAt DateTime  @default(now())
  approvedBy  String? // ID of the approver (captain, host, or admin)
  approvedAt  DateTime?

  @@unique([userId, teamId]) // Prevent duplicate requests
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  message   String
  link      String? // Optional link to the relevant page
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum GameMode {
  TIME_BASED
  POINT_ASSIGNMENT
  COMBO
}

enum RoundType {
  POINT_BASED
  TIME_BASED
  WAGER
  LIGHTNING
  IMAGE
}

enum PointSystem {
  POOL
  FLAT
}

enum QuestionType {
  SINGLE
  MULTIPLE_CHOICE
  ORDERED
  WAGER
  IMAGE
}
